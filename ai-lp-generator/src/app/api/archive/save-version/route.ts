import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase-server'
import { uploadProjectArchive } from '@/lib/storage'
import { writeFileSync, mkdirSync } from 'fs'
import path from 'path'
import { tmpdir } from 'os'

export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerSupabaseClient()
    
    // Get current user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const body = await request.json()
    const { originalProjectId, version, pageContent, projectInfo } = body

    if (!originalProjectId || !version || !pageContent || !projectInfo) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    // Create temporary directory for the new version
    const tempDir = path.join(tmpdir(), `archive-${Date.now()}`)
    mkdirSync(tempDir, { recursive: true })
    mkdirSync(path.join(tempDir, 'src', 'app'), { recursive: true })
    mkdirSync(path.join(tempDir, 'public'), { recursive: true })

    // Write the updated page.tsx
    const pageFilePath = path.join(tempDir, 'src', 'app', 'page.tsx')
    writeFileSync(pageFilePath, pageContent, 'utf8')

    // Write updated project-info.json
    const projectInfoPath = path.join(tempDir, 'project-info.json')
    writeFileSync(projectInfoPath, JSON.stringify(projectInfo, null, 2), 'utf8')

    // Write package.json
    const packageJson = {
      name: projectInfo.siteName.toLowerCase().replace(/\s+/g, '-'),
      version: `1.${version}.0`,
      private: true,
      scripts: {
        dev: "next dev",
        build: "next build",
        start: "next start",
        lint: "next lint"
      },
      dependencies: {
        react: "^18",
        "react-dom": "^18",
        next: "14.0.4"
      },
      devDependencies: {
        typescript: "^5",
        "@types/node": "^20",
        "@types/react": "^18",
        "@types/react-dom": "^18",
        autoprefixer: "^10.0.1",
        eslint: "^8",
        "eslint-config-next": "14.0.4",
        postcss: "^8",
        tailwindcss: "^3.3.0"
      }
    }
    const packageJsonPath = path.join(tempDir, 'package.json')
    writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2), 'utf8')

    // Write basic layout.tsx
    const layoutContent = `import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: '${projectInfo.siteName}',
  description: 'Generated by AI LP Generator',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ja">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
`
    const layoutPath = path.join(tempDir, 'src', 'app', 'layout.tsx')
    writeFileSync(layoutPath, layoutContent, 'utf8')

    // Write globals.css
    const globalsCss = `@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}
`
    const globalsCssPath = path.join(tempDir, 'src', 'app', 'globals.css')
    writeFileSync(globalsCssPath, globalsCss, 'utf8')

    // Write basic README.md
    const readmeContent = `# ${projectInfo.siteName}

Generated by AI LP Generator - V0 Editor

## Getting Started

\`\`\`bash
npm run dev
# or
yarn dev
# or
pnpm dev
\`\`\`

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Version Info
- Version: ${version}
- Original Project: ${originalProjectId}
- Updated: ${projectInfo.updatedAt}
`
    const readmePath = path.join(tempDir, 'README.md')
    writeFileSync(readmePath, readmeContent, 'utf8')

    try {
      // Upload to Supabase Storage as new version
      const uploadResult = await uploadProjectArchive({
        userId: user.id,
        projectId: originalProjectId,
        version,
        directoryPath: tempDir
      })

      return NextResponse.json({
        success: true,
        message: `Version ${version} saved successfully`,
        version,
        uploadResult
      })

    } catch (uploadError) {
      console.error('Upload error:', uploadError)
      return NextResponse.json(
        { error: 'Failed to upload archive' },
        { status: 500 }
      )
    }

  } catch (error) {
    console.error('Error in POST /api/archive/save-version:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}