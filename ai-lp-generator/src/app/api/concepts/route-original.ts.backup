import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase-server'
import { 
  saveConceptMarkdown, 
  ConceptParams,
  generateMarkdownWithGemini,
  buildMarkdown
} from '@/lib/generator/concept'

export const runtime = 'nodejs'

export async function POST(request: NextRequest) {
  console.log('ğŸš¨ DEBUG: Concepts API POST request received')
  try {
    // Authentication check
    const supabase = await createServerSupabaseClient()
    const {
      data: { user },
      error: authError
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return NextResponse.json(
        { error: 'èªè¨¼ãŒå¿…è¦ã§ã™' },
        { status: 401 }
      )
    }

    const body = await request.json()
    console.log('ğŸš¨ DEBUG: Request body:', JSON.stringify(body, null, 2))
    const params: ConceptParams = {
      siteName: String(body.siteName || '').trim(),
      brief: body.brief?.trim() || '',
      problem: body.problem?.trim() || '',
      affinity: body.affinity?.trim() || '',
      solution: body.solution?.trim() || '',
      offer: body.offer?.trim() || '',
      narrowingDown: body.narrowingDown?.trim() || '',
      action: body.action?.trim() || '',
      colors: {
        primary: body.primary?.trim() || '#0EA5E9',
        accent: body.accent?.trim() || '#9333EA',
        background: body.background?.trim() || '#0B1221',
      },
      nav: String(body.nav || '')
        .split(',')
        .map((s: string) => s.trim())
        .filter(Boolean),
      logoText: body.logoText?.trim() || '',
      socials: {
        x: body.x?.trim() || '',
        linkedin: body.linkedin?.trim() || '',
        github: body.github?.trim() || '',
      },
      contact: {
        email: body.email?.trim() || '',
        url: body.url?.trim() || '',
      },
    }

    if (!params.siteName) {
      return NextResponse.json({ error: 'ã‚µã‚¤ãƒˆåã¯å¿…é ˆã§ã™ã€‚' }, { status: 400 })
    }

    console.log('ğŸ’­ ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ç”Ÿæˆé–‹å§‹:', { siteName: params.siteName })
    
    // Generate markdown (try Gemini first, fallback to manual)
    let markdown: string
    try {
      markdown = await generateMarkdownWithGemini(params, params.brief)
      console.log('âœ¨ Gemini APIã§ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ç”Ÿæˆå®Œäº†')
    } catch (error) {
      console.log('âš ï¸ Geminiç”Ÿæˆå¤±æ•—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½¿ç”¨:', error)
      markdown = buildMarkdown(params)
      console.log('ğŸ“ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ç”Ÿæˆå®Œäº†')
    }

    // Save with the generated markdown
    const result = await saveConceptMarkdown({ ...params, markdown })
    console.log('ğŸ’¾ ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜å®Œäº†:', result.filePathRelative)
    
    // Save to Supabase concepts table
    console.log('ğŸš¨ DEBUG: About to insert to Supabase concepts table')
    const { data: conceptData, error: insertError } = await supabase
      .from('concepts')
      .insert({
        site_name: params.siteName,
        pasona_input: {
          problem: params.problem,
          affinity: params.affinity,
          solution: params.solution,
          offer: params.offer,
          narrowing_down: params.narrowingDown,
          action: params.action
        },
        markdown_content: markdown,
        brief: params.brief,
        colors: params.colors,
        nav: params.nav,
        logo_text: params.logoText,
        socials: params.socials,
        contact: params.contact,
        file_path: result.filePathRelative,
        user_id: user.id
      })
      .select()
      .single()

    if (insertError) {
      console.error('ğŸš¨ DEBUG: Database insert error:', insertError)
      console.error('ğŸš¨ DEBUG: Full error details:', JSON.stringify(insertError, null, 2))
      return NextResponse.json(
        { error: 'Failed to save concept to database', details: insertError.message },
        { status: 500 }
      )
    }

    console.log('âœ… Concept saved to database with ID:', conceptData.id)
    
    return NextResponse.json({ 
      success: true, 
      ...result,
      conceptId: conceptData.id,
      message: `ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’ä½œæˆã—ã¾ã—ãŸ: ${result.filePathRelative}`
    })
  } catch (error: any) {
    console.error('ğŸš¨ DEBUG: Catch block error:', error)
    console.error('ğŸš¨ DEBUG: Error stack:', error?.stack)
    return NextResponse.json(
      { success: false, error: error?.message || 'Failed to save concept' },
      { status: 500 },
    )
  }
}


